#!/usr/bin/env ruby

ENV['RAILS_ENV'] = 'development'

require_relative '../config/environment'

host = ARGV[0] || raise(ArgumentError, 'No host')
obo_token = ARGV[1] || raise(ArgumentError, 'No OBO token')
sktalk_message = ARGV[2] || 'tmp/sktalk_message.xml'

def sktalk_message(template:, remove_message_identifier: false)
  message = SktalkMessages.from_xml(File.read(template))
  message.header.message_info.message_id = remove_message_identifier ? '' : SecureRandom.uuid
  message.header.message_info.correlation_id = SecureRandom.uuid
  body = Nokogiri::XML::Document.wrap(message.body.any.first.owner_document)
  body.xpath('/:MessageContainer/:MessageId').first.content = message.header.message_info.message_id
  SktalkMessages.to_xml(message)
end

def request(host, action, obo_token, sktalk_message)
  api_token_key_pair = OpenSSL::PKey::RSA.new(File.read('security/api-token.private.pem'))
  obo_token_key_pair = OpenSSL::PKey::RSA.new(File.read('security/obo-token.private.pem'))
  obo_token_payload, _ = JWT.decode(obo_token, obo_token_key_pair, true, algorithm: 'RS256')
  api_token = JWT.encode({ exp: obo_token_payload['exp'], jti: SecureRandom.uuid, obo: obo_token }, api_token_key_pair, 'RS256', cty: 'JWT')

  system "curl -X POST -d 'token=#{api_token}&message=#{sktalk_message}' #{host}/api/sktalk/#{action}"
end

request host, 'receive_and_save_to_outbox', obo_token, sktalk_message(template: sktalk_message)
request host, 'receive_and_save_to_outbox', obo_token, sktalk_message(template: sktalk_message, remove_message_identifier: true)
